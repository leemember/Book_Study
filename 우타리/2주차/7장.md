# 7장 비동기 호출

## API 요청

### fetch로 API 요청
- 백엔드에서 기능 변경해야될 경우 URL 을 수정하게 된다면 URL 변경 뿐만 아니라 여러 서버에서 API를 요청할 때, 타임아웃 설정이 필요하다 또는 모든 요청에 커스텀 헤더가 필요하다와 같은 새로운 API 요청 정책이 추가될 때마다 계속해서 비동기 호출 코드를 수정해야 하는 번거로움이 발생한다. 이때, API 요청 정책이 추가되어 코드가 변경될 수 있다는 것을 감안한다면 비동기 호출 코드는 컴포넌트 영역에서 분리되어 다른 영역(서비스 레이어)에서 처리되어야 한다.
또한 쿼리 매개변수나 커스텀 헤더 추가 또는 쿠키를 읽어 코튼을 집어 넣는 등 다양한 API 정책이 추가될 수 있는데 이 모든 것을 구현하기에는 번거로운 일이다.

그러니

### ⭐️ axios 활용하기
- fetch는 내장 라이브러리이기 때문에 따로 임포트하거나 설치할 필요 없이 사용할 수 있다. 그러나 많은 기능을 사용하려면 직접 구현해서 사용해야 한다. 이러한 번거로움 때문에 fetch 함수를 직접 쓰는 대신 axios 라이브러리를 사용하는 것이 좋다.

```ts
const api:AxiosInstance = axios.create({
  baseUrl: 'https://api.baemin.com',
  timeout: 5000,
})

const fetchCart = ():AxiosPromise<FetchCartResponse> =>
  apiRequester.get<FetchCartResponse> ("cart")
```
이처럼 사용할 수가 있다.

그리고 requester 별로 다른 헤더를 설정해야하는 로직이 필요할 수도 있는데, 이때 Axios의 인터셉터 기능을 사용하여 requester에 따라 비동기 호출 내용을 추가하여 처리할 수 있다. 또한 API 에러를 처리할 때 하나의 에러 객체로 묶어서 처리할 수도 있다.

(1) interceptor 기능을 사용하여 header를 설정하는 기능을 넣거나 에러를 처리할 수 있다.

```ts
apiRequester.interceptors.request.use(setRequestDefaultHeader);
const orderApiRequester: AxiosInstance = axios.create({
  baseURL: orderApiBaseUrl,
  ...defaultConfig
})
```

빌더패턴으로도 APIBuilder같은 클래스 형태로 구성하기도 한다.
빌더패턴이란? 객체 생성을 더 편리하고 가독성 있게 만들기 위한 디자인 패턴 중 하나다. 주로 복잡한 객체의 생성을 단순화하고, 객체 생성 과정을 분리하여 객체를 조립하는 방법을 제공한다.

class 형식이라고 보면된다.

ex)

```ts
class API {
  readonly method: HTTPMethod;
  baseURL?: string;
  header?: HTTPHeaders;
  
  (...)
}
```

클래스형은 보일러플레이트 코드가 많다는 단점을 가지고 있다. 하지만 옵션이 다양한 경우에 인터셉터를 설정값에 따라 적용하고, 필요 없는 인터셉터를 선택적으로 사용할 수 있다는 장점도 지니고있다.

*보일러플레이트 코드란? 어떤 기능을 사용할 때 반복적으로 사용되는 기본적인 코드를 말함


----

### API 응답 타입 지정하기
같은 서버에서 오는 응답의 형태는 대체로 통일되어 있어 하나의 Response 타입으로 묶일 수 있다.

ex)

```ts
interface Response<T> {
  data: T;
  status: string;
  serverDateTime: string;
  errorCode?: string; // FAIL, ERROR
  errorMessage?: string; // FAIL, ERROR
}

const fetchCart = (): AxiosPromise<Response<FetchCartResponse>> => apiRequester.get<Response<FetchCartResponse>> "cart"

const postCart = (postCartRequest: PostCartRequest):AxiosPromise<Response<PostCartResponse>> => apiRequester.post<Response<PostCartResponse>>("cart", postCartRequest);
```

이와 같이 서버에서 오는 응답을 통일해줄 때 주의할 점이 있다.
Response 응답 타입을 apiRequester 내에서 처리하고 싶을 때, 이렇게 하면 POST나 PUT 같이 응답이 없을 수 있는 API를 처리하기가 까다로워진다.

따라서 Response 타입은 apiRequester가 모르게 관리되어야 한다.
API 요청 및 응답 값 중에서는 하나의 API 서버에서 다른 API 서버로 넘겨주기만 하는 값도 존재할 수 있다. 해당 값에 어떤 응답이 들어있는지 알 수 없거나 값의 형식이 달라지더라도 로직에 영향을 주지 않는 경우에는 `unknown` 타입을 사용하여 알 수 없는 값임을 표현해야한다.


```ts
interface response {
  data: {
    cartItems: CartItem[];
    forPass: unknown;
  }
}
```


만약 forpass 안에 프론트 로직에서 사용해야 하는 값이 있다면 어전히 어떤 값이 들어올지 모르는 상태이기 때문에 `unknown`로 유지한다. 
로그를 위해 단순히 받아서 넘겨주는 값의 타입은 언제든지 변경될 수 있으므로 forPass 내의 값을 사용하지 않아야한다. 다만, 이미 설계된 프로덕트에서 쓰고 있는 값이라면 프론트 로직에서 써야하는 값에 대해서만 타입을 선언한 다음에 사용하는 것이 좋다.

```ts
type ForPass = {
  type: "A" | "B" | "C"
}

const isTargetValue = () => (data.forPass as ForPass).type === "A";
```

### 뷰 모델 (View Model) 사용하기

API 응답은 변할 가능성이 크다.
새로운 프로젝트는 서버 스펙이 자주 바뀌기 때문에 뷰모델을 사용하여 API 변경에 따라 범위를 한정해줘야 한다.
특정 객체 리스트를 조회하여 리스트 각각의 내용과 리스트 전체 길이 등을 보여줘야 하는 화면을 떠올렸을 때 다음과 같이 구성될 것이다.

```ts
interface Response<T> {
  data: T;
  status: string;
  serverDateTime: string;
  errorCode?: string; // FAIL, ERROR
  errorMessage?: string; // FAIL, ERROR
}

interface ListResponse {
  items: ListItem[];
}

const fetchList = async (filter?: ListFetchFilter): Promise<ListResponse> => {
  const { data } = await api
  .params({ ...filter })
  .get("/apis/get-list")
  .call<Response<ListResponse>>();

  return { data };
}
```

흔히 좋은 컴포넌트는 변경될 이유가 하나뿐인 컴포넌트라고 말한다. API 응답의 itesm 인자를 좀 더 정확한 개념으로 나타내기 위해 jobItmes, cartItems 같은 이름으로 수정하면 해당 컴포넌트도 수정해야 한다.

이렇게 수정해야 할 컴포넌트가 API 1개에 하나라면 좋겠지만, API를 사용하는 기존 컴포넌트도 수정되어야 한다.

이런 상황이 프로젝트 초기에 자주 발생하곤 한다.
이 문제를 해결하기 위해서 뷰 모델을 도입할 수 있다.


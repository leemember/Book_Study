# CSS in JS

CSS in JS 는 CSS in CSS 보다 높은 추상화 수준과 DX를 제공한다.

JS 로 스타일을 선언적이고 유지보수할 수 있는 방식으로 표현할 수 있다는 장점으로 인기를 얻었다.

## 인라인 스타일과 CSS in JS 의 차이

### inline style

```tsx
const textStyles = {
	color: white;
	backgroundColor: black
}

const Component = () => (<p style={textStyles}></p>)
```

```html
<p style="color: white; background-color: black;"></p>
```

### CSS in JS (Styled Components)

```jsx
import styled from "styled-components";

const Text = styled.p`color:white, background:black`;

const Component = () => (<Text></Text>)
```

```html
<style>
.hash {
	background-color: black;
	color: white;
}
</style>

<p clss="hash"></p>
```

인라인 스타일은 DOM 노드에 직접적으로 스타일을 추가한 반면 CSS in JS 는 별도의 style 이 생성된다.

CSS in JS 를 사용하면 실제로 CSS 가 생성되기 때문에 여러 CSS 기능을 편하게 사용할 수 있다.

## 크리스토퍼 쉬도 (메타 엔지니어) 가 언급한 CSS의 문제점

1. Global Namespace
    1. 모든 스타일이 전역 공간을 공유하므로 중복되지 않는 이름을 고민해야 한다.
2. Dependencies
    1. CSS 와 JS 의 의존성이 달라서 사용하지 않는 스타일이 포함되거나, 필요한 스타일이 누락됨
3. Dead Code Elimination
    1. 더이상 사용 되지 않는 CSS 제거가 어려움
4. Minification
    1. 클래스 이름을  minify 하기 어려움
5. Sharing Constants
    1. JS 와 변수 공유가 불가 (최근에는 css variable 도입됨)
6. Non deterministic Resolution
    1. CSS 로드 순서에 따라 우선순위가 변경됨
7. Isolation
    1. CSS 의 외부 수정 관리가 어려움

## 개인적으로 생각하는 CSS 의 문제점

CSS 의 근본적인 문제는 브라우저에 있다고 생각합니다. 과거 프론트엔드 라는 포지션이 세분화 되지 않고 퍼블리셔가 퍼블리싱한 화면을 그대로 가져다 쓰던 시절부터 현재까지 대다수의 작업자가 CSS 및 HTML 에 대해 모르는 경우가 다반사 입니다. 이 때문에 브라우저 개발사 에서는 잘못 작성된 마크업 이나 CSS 에 대해 자체적으로 보정해서 렌더링 하도록 개발 하였습니다. 성능과 최적화 역시 마찬가지 입니다.

저는 이 때문에 초기에는 빠르게 서비스를 런칭할 수 있었지만 작업자간의 역량 차이가 극심 해졌다고 생각합니다.

잘못 써도 돌아가게 되니 역량이 낮으면 낮을수록 잘못된 방식을 저번에 이렇게 하니 되더라 > 이러한 구현은 이렇게 한다 로 받아들여 코드 품질이 갈수록 저하되어 가는 악순환이 발생합니다. 대부분의 퍼블리셔는 성능, 유지보수성을 고려하지 않으니 당연한 결과입니다.

마찬가지로 CSS 의 경우 global namespace 를 가지고 있고 작성 순서에 따라 우선순위가 달라지게 됩니다. 이로 인해 동일한 스타일시트를 가져오는 순서에 따라 적용되는 범위가 다르게 되고 이로 인하여 불필요하게 선택자를 중복해서 남발하는 사람들이 기하급수적으로 증가 하였습니다. 이러한 사람들의 작업물을 리팩토링 하게 되면 CSS 의 크기가 1/3 이하로 줄어드는건 더이상 놀랍지도 않고 흔한 경우 입니다.

성능적인 측면에서는 네트워크, 브라우저, 하드웨어 등의 성능이 비약적으로 올라감에 따라 이전보다 더 성능에 신경쓰지 않는 작업자가 증가 하고 있습니다. 그러다보니 심한 경우에는 한 페이지에서 마크업 보다 스타일시트의 용량이 더 큰 경우도 종종 발견되고 최종 결과물의 절반 이상이 스타일시트인 경우도 있습니다. 당연히 해당 스타일 시트의 상당수는 쓸모 없습니다.

마지막으로 사실 이 부분은 CSS 의 문제라기 보다는 개개인의 지능에 관한 문제 입니다만, 특히 CSS 에서 두드러져서 작성 하자면 생각보다 구조화와 재사용성에 대해 이해를 하지 못하는 사람이 많습니다. (이 부분은 개발자를 포함 모든 직군이 마찬가지입니다) 그러다보니 프로젝트 전반적으로 사용되는 동일한 스타일에 대해 분리하여 재사용하지 못하고 모든 element 마다 각자 선택자를 지정하여 스타일을 추가 하는 작업자들이 많습니다. 그러다보니 공통적으로 사용되는 UI 가 변경 될 경우 수십곳을 수정해야 하는 경우가 발생합니다.

이러한 분들이 vue, react 등 모던 라이브러리나 프레임워크를 사용하게 되면 컴포넌트 별 스타일 시트 파일을 추가하고 해당 컴포넌트는 해당 스타일 시트의 영향만 받게 작성하게 되는데 이 과정에서 불필요하게 재작성하는 코드가 많아지게 되고 사용자가 다운로드 받아야 하는 파일은 많아지고 전반적인 성능 및 유지보수성이 확연히 떨어지게 됩니다. 사실 이 부분이 bootstrap, tailwind 가 나오게 된 배경 중 하나이며 최근 가장 주목받는 라이브러리인 이유 입니다.

## CSS in JS 의 장점

1. 컴포넌트 로 생각할 수 있다.
    1. 개별 스타일 시트를 관리하지 않아도 되기 때문에 유지보수가 편하다.
2. 부모와 분리할 수 있다.
    1. CSS 는 명시적으로 선언하지 않은 경우 부모 엘리먼트 에서 자동으로 상속되는 속성들이 존재한다. 
    CSS in JS 는 이러한 속성들을 상속받지 않기 때문에 부모와 독립적으로 동작한다.
3. 별도의 scope 를 가진다.
    1. 기존의 css 작성 방식은 전역 namespace 를 가지기 때문에 선택자 간 충돌이 빈번하게 발생한다.
    CSS in JS 는 컴파일 단계에서 고유한 이름을 생성하기 때문에 선택자 충돌에서 자유롭다
4. Vender Prefix 가 자동으로 생성된다.
5. JS 코드와 상수를 공유할 수 있다.

## CSS in JS 의 단점

1. CSS-in-JS 는 런타임 오버헤드를 더합니다.
컴포넌트가 렌더링 될 때 CSS-in-JS 라이브러리는 document에 삽입할 수 있는 일반 CSS로 스타일을 “직렬화”해야 합니다. 이런 부분이 추가 CPU를 차지한다는 것은 분명하지만 앱의 성능에 눈에 띄는 영향을 미치기에 충분한지는 확인해봐야 합니다. 다음 섹션에서 좀 더 자세히 조사해보도록 하겠습니다.
2. CSS-in-JS는 번들 크기를 늘립니다.
사이트를 방문하는 각 사용자는 CSS-in-JS 라이브러리용 자바스크립트를 다운로드해야 합니다. Emotion 은 압축 되었을 때  7.9KB 이고 styled-components 는 [1](https://bundlephobia.com/package/styled-components@5.3.6)2.7KB 입니다.
두 라이브러리 모두 거대하지는 않지만 모두 추가됩니다.(react + react-dom 은 44.5KB)
3. CSS-in-JS는 React DevTools를 어지럽힙니다.
CSS 프로퍼티를 사용하는 각 요소에 대해 Emotion은 `<EmotionCssPropInternal>` 및 `<Insertion>` 컴포넌트를 렌더링합니다. 많은 요소에서 `css` 프로퍼티를 사용하는 경우 아래 그림처럼 Emotion의 내부 컴포넌트가 React DevTools를 어지럽힐 수 있습니다.
    
    
    ## CSS in JS 가 비판받는 점 (사용하지 않는 사람들이 지적하는 주된 이유)
    
    ### **CSS 규칙을 자주 삽입하면 브라우저에서 더 많은 추가 작업을 수행해야 합니다**.
    
    리액트 코어 팀 멤버이자 리액트 훅의 디자이너였던 [Sebastian Markbåge](https://github.com/sebmarkbage)는 리액트 18 작업 그룹에서 CSS-in-JS 라이브러리가 리액트 18과 함께 작동하도록 변경해야 하는 방법과 미래에 대해 [매우 유익한 토론](https://github.com/reactwg/react-18/discussions/110)을 작성했습니다. 그는 일반적으로 런타임 CSS-in-JS의 경우 특히 다음과 같이 해야 한다고 말합니다.
    
    > 동시(concurrent) 렌더링에서, 리액트는 렌더링 사이에 브라우저에 양보할 수 있습니다. 컴포넌트에 새 규칙을 삽입하면 리액트가 생성되고, 브라우저는 해당 규칙이 기존 트리에 적용되어 있는지를 다시 확인합니다. 이후 스타일 규칙을 다시 계산하게 됩니다. 그런 다음 리액트는 다음 컴포넌트를 렌더링 하고, 해당 컴포넌트는 새로운 규칙을 발견하고 다시 실행하기를 반복합니다.
    > 
    > 
    > ***이런 부분은 리액트가 렌더링 하는 동안 모든 프레임에 대해 모든 CSS 규칙을 효과적으로 재계산하게 합니다**. 하지만 매우 느립니다.*
    > 
    
    Sebastian의 이 인용문은 특히 `useInsertionEffect`가 없는 리액트 동시(concurrent) 모드의 성능을 말합니다.
    
    이 문제의 가장 나쁜 점은 (런타임 CSS-in-JS 컨텍스트 내에서) 해결할 수 있는 문제가 아니라는 것입니다. CSS-in-JS 라이브러리는 컴포넌트가 렌더링 될 때 새로운 스타일 규칙을 삽입해 작동하며 이는 근본적으로 성능에 좋지 않습니다.
    
    ### CSS-in-JS를 사용하면 특히 SSR 및 혹은 또는 컴포넌트 라이브러리를 사용할 때 잘못될 수 있는 부분이 훨씬 더 많습니다.
    
    CSS in JS 라이브러리의 issues 에는 빈번하게 SSR 관련, 다른 UI 라이브러리와의 호환성 이슈가 올라오는데 주된 이유는 아래와 같습니다.
    
    - Emotion 의 여러 인스턴스가 한 번에 로드 됩니다. 이는 여러 인스턴스가 모두 동일한 버전의 Emotion인 경우에도 문제를 일으킬 수 있습니다.
    - 컴포넌트 라이브러리는 스타일이 삽입되는 순서를 완전히 제어할 수 없는 경우가 많습니다.
    - Emotion의 SSR지원은 리액트 17과 리액트 18에서 다르게 작동합니다.
